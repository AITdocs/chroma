# 单节点 Chroma：性能与限制

Chroma 的单节点版本设计用于易于部署和维护，同时仍然提供满足广泛生产应用场景的强劲性能。

为了帮助您了解在什么情况下单节点 Chroma 适合您的使用场景，我们进行了一系列压力测试和性能实验，以评估系统的功能并发现其限制和边界情况。我们还分析了在不同硬件配置下的这些边界，以确定不同工作负载适合的部署方式。

本文档描述了这些发现，以及一些通用原则，帮助您最大限度地发挥 Chroma 部署的性能。

## 结果概览

粗略而言，在不同 EC2 实例类型上，针对一个非常典型的工作负载（如下所述），您可以期望 Chroma 提供的性能大致如下：

- 1024 维嵌入向量
- 小型文档（100-200 个词）
- 每条记录包含三个元数据字段

| 实例类型        | 系统内存 | 近似最大集合大小 | 平均延迟（查询） | 99.9% 延迟（查询） | 平均延迟（插入，批次大小=32） | 99.9% 延迟（插入，批次大小=32） | 月成本     |
|-----------------|----------|------------------|------------------|--------------------|----------------------------|-------------------------------|------------|
| **r7i.2xlarge** | 64GB     | 15,000,000       | 5ms              | 7ms               | 112ms                      | 405ms                         | $386.944   |
| **t3.2xlarge**  | 32GB     | 7,500,000        | 5ms              | 33ms              | 149ms                      | 520ms                         | $242.976   |
| **t3.xlarge**   | 16GB     | 3,600,000        | 4ms              | 7ms               | 159ms                      | 530ms                         | $121.888   |

| **t3.large**    | 8          | 1,700,000                   | 4ms                  | 10ms                  | 199ms                 | 633ms                  | $61.344      |
| **t3.medium**   | 4          | 700,000                     | 5ms                  | 18ms                  | 191ms                 | 722ms                  | $31.072      |
| **t3.small**    | 2          | 250,000                     | 8ms                  | 29ms                  | 231ms                 | 1280ms                  | $15.936      |

{% br %}{% /br %}

**不推荐**在内存少于 2GB 的系统上部署 Chroma。

请注意，此表中的延迟数据适用于较小的数据集。随着数据集的增大，延迟也会增加：有关完整分析，请参阅下方的[延迟与数据集大小](./performance#latency-and-collection-size)。

## 内存与数据集大小

Chroma 使用 [`hnswlib`](https://github.com/nmslib/hnswlib) 的一个分支来高效地对嵌入向量进行索引和搜索。HNSW 算法要求将嵌入索引驻留在系统 RAM 中，以便进行查询或更新。

因此，可用系统内存的大小决定了 Chroma 数据集（或多个并发使用的数据集）的上限。如果数据集的大小超过了可用内存，操作系统开始将内存交换到磁盘时，插入和查询的延迟将迅速飙升。索引的内存布局不适合交换，系统将很快变得无法使用。

因此，用户应始终规划足够的 RAM 来容纳预期的嵌入总量。

为了分析所需的 RAM 大小，我们在不同规格的 EC2 实例上启动了 Chroma 实例，然后持续插入嵌入向量，直到每个系统变得无响应。正如预期的那样，这个故障点与 RAM 和嵌入数量呈线性关系。

对于 1024 维的嵌入向量，每个嵌入附带三条元数据记录和一个小文档的情况，可以使用公式 `N = R * 0.245` 来估算最大集合大小，其中 `N` 表示集合大小的最大值（单位：百万），`R` 表示所需系统内存（单位：GB）。请注意，你还需要额外预留至少 1GB 内存供系统其他用途使用，这部分不包含 Chroma 所需的内存。

这一估算模式在嵌入数量达到约 700 万之前都是成立的，这也是我们测试所达到的最大规模。在这个规模下，Chroma 依然保持快速和稳定，我们并未发现 Chroma 数据库大小的明确上限。

## 磁盘空间与集合大小

Chroma 会将每个集合持久化到磁盘。所需磁盘空间由两部分组成：一部分是保存 HNSW 嵌入索引所需的空间，另一部分是用于存储文档和嵌入元数据的 SQLite 数据库所占用的空间。

HNSW 索引的持久化空间估算与内存大小的估算类似。作为经验法则，确保系统的存储容量至少与内存容量相当，并额外预留数 GB 空间以应对操作系统和其他应用程序的开销。

SQLite 数据库所占用的空间变化较大，完全取决于是否在 Chroma 中保存文档和元数据，以及它们的具体大小。举个例子：一个包含约 4 万个文档（每个文档约 1000 个词）和约 60 万条元数据记录的集合，其对应的 SQLite 数据库大小约为 1.7GB。

元数据数据库本身并没有严格的大小上限：SQLite 本身支持达到 TB 级别的数据库，并能有效地分页到磁盘。

在大多数实际使用场景中，HNSW 索引在内存中的大小和性能往往会先于元数据数据库成为限制 Chroma 集合规模的关键因素。

## 延迟与集合大小

随着集合规模的增大和索引尺寸的增长，插入和查询操作的完成时间都会变长。增长速率起初较为平缓，之后大致呈线性增长，其拐点和斜率取决于可用CPU的数量和速度。在图表的末端，某些实例（如 `t3.2xlarge`）会出现极端峰值，这是由于实例达到了内存限制所致。

### 查询延迟

{% MarkdocImage lightSrc="/query_latency_1_0_10_light.png" darkSrc="/query_latency_1_0_10.png" alt="查询延迟性能" %}
{% /MarkdocImage %}

### 插入延迟

{% MarkdocImage lightSrc="/insert_latency_1_0_10_light.png" darkSrc="/insert_latency_1_0_10.png" alt="插入延迟性能" %}
{% /MarkdocImage %}

{% note type="tip" title="" %}
如果你使用了多个集合，其性能表现与所有集合中向量总量相关的性能表现非常相似。将集合拆分成多个较小的集合并不会带来性能提升，但只要所有集合能够同时容纳在内存中，也不会造成性能下降。
{% /note %}

## 并发性

系统能够并行处理并发操作。对于插入操作，由于写入会被写入日志，并且每 N 次操作刷新一次，因此平均延迟不会随着写入线程数的增加而显著波动，但会随着批次大小的增加而上升，因为较大的批次更有可能触发刷新阈值。查询操作会并行化到实例中可用的 vCPU 数量上限，超过此上限后，系统开始排队，从而导致延迟呈线性增长。

{% MarkdocImage lightSrc="/concurrent_writes_1_0_10_light.png" darkSrc="/concurrent_writes_1_0_10.png" alt="并发写入" %}
{% /MarkdocImage %}

{% MarkdocImage lightSrc="/concurrent_queries_1_0_10_light.png" darkSrc="/concurrent_queries_1_0_10.png" alt="并发查询" %}
{% /MarkdocImage %}

有关在您可以控制并发数量的情况下（例如在批量插入数据时）如何优化用户数量以达到最大吞吐量的讨论，请参阅下面的[插入吞吐量](./performance#insert-throughput)部分。

# CPU 速度、核心数量与类型

{% MarkdocImage lightSrc="/cpu_mean_query_latency_1_0_10_light.png" darkSrc="/cpu_mean_query_latency_1_0_10.png" alt="CPU 平均查询延迟" %}
{% /MarkdocImage %}

# 插入吞吐量

一个常见的问题是：在需要批量插入数据的情况下，插入的速度能有多快？以及怎样才能快速地插入大量数据？

第一个需要考虑的重要因素是并发插入请求的数量。

如上文 [并发性](./performance#concurrency) 部分所述，插入吞吐量会从并发性提升中受益。第二个需要考虑的因素是每个请求的批次大小。由于较小的批次大小具有较高的开销，因此性能会随着批次大小的增加而提升，直到达到 CPU 的饱和点。在达到 CPU 饱和后（大约在批次大小为 150 时），吞吐量趋于稳定。

实验也验证了这一点：在批次大小为 100 至 500 之间时，整体吞吐量（插入的嵌入向量总数，涵盖不同批次大小和请求数量）保持相对稳定：

{% MarkdocImage lightSrc="/concurrent_inserts_1_0_10_light.png" darkSrc="/concurrent_inserts_1_0_10.png" alt="并发插入" %}
{% /MarkdocImage %}

鉴于较小的批次具有更低且更稳定的延迟，并且不太可能导致超时错误，我们建议选择该曲线中较小的批次大小：50 到 250 之间的任意值都是合理的选择。

## 结论

在合适的硬件部署条件下，用户可以放心地使用 Chroma 来处理接近数千万个嵌入（embeddings）的使用场景。Chroma 在读写操作上的平均和上限延迟表现使其成为一个适用于几乎所有中小型 AI 应用程序的平台，可以支持可能同时有数千名人用户访问（具体取决于您的应用程序后端访问模式）。

然而，作为一种单节点解决方案，Chroma 并不能无限扩展。如果您发现自己的需求超出了本分析中所列出的参数范围，我们非常希望听到您的反馈。请填写[此表格](https://airtable.com/appqd02UuQXCK5AuY/pagr1D0NFQoNpUpNZ/form)，我们将邀请您加入一个专门面向生产环境用户的 Slack 工作区，以便为您提供更专业的支持。我们很乐意协助您进行系统设计的思考，无论 Chroma 是否适合您的架构，或者您是否适合使用我们即将推出的分布式云服务。